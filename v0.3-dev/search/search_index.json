{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Microgrid API Client","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This project provides a Python client for the Frequenz Microgrid API that is more idiomatic to use in Python than the automatically-generated gRPC client provided by <code>protoc</code>.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Microgrid API Client","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>microgrid</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/microgrid/","title":"microgrid","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid","title":"frequenz.client.microgrid","text":"<p>Client to connect to the Microgrid API.</p> <p>This package provides a low-level interface for interacting with the microgrid API.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient","title":"frequenz.client.microgrid.ApiClient","text":"<p>Microgrid API client implementation using gRPC as the underlying protocol.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>class ApiClient:\n    \"\"\"Microgrid API client implementation using gRPC as the underlying protocol.\"\"\"\n\n    def __init__(\n        self,\n        grpc_channel: grpc.aio.Channel,\n        target: str,\n        retry_strategy: retry.Strategy = retry.LinearBackoff(),\n    ) -&gt; None:\n        \"\"\"Initialize the class instance.\n\n        Args:\n            grpc_channel: asyncio-supporting gRPC channel\n            target: server (host:port) to be used for asyncio-supporting gRPC\n                channel that the client should use to contact the API\n            retry_strategy: The retry strategy to use to reconnect when the connection\n                to the streaming method is lost.\n        \"\"\"\n        self.target = target\n        \"\"\"The location (as \"host:port\") of the microgrid API gRPC server.\"\"\"\n\n        self.api = MicrogridStub(grpc_channel)\n        \"\"\"The gRPC stub for the microgrid API.\"\"\"\n\n        self._broadcasters: dict[int, streaming.GrpcStreamBroadcaster[Any, Any]] = {}\n        self._retry_strategy = retry_strategy\n\n    async def components(self) -&gt; Iterable[Component]:\n        \"\"\"Fetch all the components present in the microgrid.\n\n        Returns:\n            Iterator whose elements are all the components in the microgrid.\n\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\n        try:\n            # grpc.aio is missing types and mypy thinks this is not awaitable,\n            # but it is\n            component_list = await cast(\n                Awaitable[PbComponentList],\n                self.api.ListComponents(\n                    PbComponentFilter(),\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            )\n\n        except grpc.aio.AioRpcError as err:\n            msg = f\"Failed to list components. Microgrid API: {self.target}. Err: {err.details()}\"\n            raise grpc.aio.AioRpcError(\n                code=err.code(),\n                initial_metadata=err.initial_metadata(),\n                # We need to ignore these errors for some reason, otherwise we get this\n                # mypy error:\n                #   Argument \"trailing_metadata\" to \"AioRpcError\" has incompatible type\n                #   \"tuple[_Metadatum, ...]\"; expected \"Metadata\"\n                # According to grpc.aio documentation, both should have the type\n                # Metadata.\n                # https://grpc.github.io/grpc/python/grpc_asyncio.html#grpc.aio.AioRpcError\n                trailing_metadata=err.trailing_metadata(),  # type: ignore[arg-type]\n                details=msg,\n                debug_error_string=err.debug_error_string(),\n            )\n        components_only = filter(\n            lambda c: c.category is not PbComponentCategory.COMPONENT_CATEGORY_SENSOR,\n            component_list.components,\n        )\n        result: Iterable[Component] = map(\n            lambda c: Component(\n                c.id,\n                component_category_from_protobuf(c.category),\n                component_type_from_protobuf(c.category, c.inverter),\n                component_metadata_from_protobuf(c.category, c.grid),\n            ),\n            components_only,\n        )\n\n        return result\n\n    async def metadata(self) -&gt; Metadata:\n        \"\"\"Fetch the microgrid metadata.\n\n        If there is an error fetching the metadata, the microgrid ID and\n        location will be set to None.\n\n        Returns:\n            the microgrid metadata.\n        \"\"\"\n        microgrid_metadata: PbMicrogridMetadata | None = None\n        try:\n            microgrid_metadata = await cast(\n                Awaitable[PbMicrogridMetadata],\n                self.api.GetMicrogridMetadata(\n                    Empty(),\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            )\n        except grpc.aio.AioRpcError:\n            _logger.exception(\"The microgrid metadata is not available.\")\n\n        if not microgrid_metadata:\n            return Metadata()\n\n        location: Location | None = None\n        if microgrid_metadata.location:\n            location = Location(\n                latitude=microgrid_metadata.location.latitude,\n                longitude=microgrid_metadata.location.longitude,\n            )\n\n        return Metadata(microgrid_id=microgrid_metadata.microgrid_id, location=location)\n\n    async def connections(\n        self,\n        starts: set[int] | None = None,\n        ends: set[int] | None = None,\n    ) -&gt; Iterable[Connection]:\n        \"\"\"Fetch the connections between components in the microgrid.\n\n        Args:\n            starts: if set and non-empty, only include connections whose start\n                value matches one of the provided component IDs\n            ends: if set and non-empty, only include connections whose end value\n                matches one of the provided component IDs\n\n        Returns:\n            Microgrid connections matching the provided start and end filters.\n\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\n        connection_filter = PbConnectionFilter(starts=starts, ends=ends)\n        try:\n            valid_components, all_connections = await asyncio.gather(\n                self.components(),\n                # grpc.aio is missing types and mypy thinks this is not\n                # awaitable, but it is\n                cast(\n                    Awaitable[PbConnectionList],\n                    self.api.ListConnections(\n                        connection_filter,\n                        timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                    ),\n                ),\n            )\n        except grpc.aio.AioRpcError as err:\n            msg = f\"Failed to list connections. Microgrid API: {self.target}. Err: {err.details()}\"\n            raise grpc.aio.AioRpcError(\n                code=err.code(),\n                initial_metadata=err.initial_metadata(),\n                # See the comment in def components() for why we need to ignore\n                trailing_metadata=err.trailing_metadata(),  # type: ignore[arg-type]\n                details=msg,\n                debug_error_string=err.debug_error_string(),\n            )\n        # Filter out the components filtered in `components` method.\n        # id=0 is an exception indicating grid component.\n        valid_ids = {c.component_id for c in valid_components}\n        valid_ids.add(0)\n\n        connections = filter(\n            lambda c: (c.start in valid_ids and c.end in valid_ids),\n            all_connections.connections,\n        )\n\n        result: Iterable[Connection] = map(\n            lambda c: Connection(c.start, c.end), connections\n        )\n\n        return result\n\n    async def _new_component_data_receiver(\n        self,\n        *,\n        component_id: int,\n        expected_category: ComponentCategory,\n        transform: Callable[[PbComponentData], _ComponentDataT],\n        maxsize: int,\n    ) -&gt; Receiver[_ComponentDataT]:\n        \"\"\"Return a new broadcaster receiver for a given `component_id`.\n\n        If a broadcaster for the given `component_id` doesn't exist, it creates a new\n        one.\n\n        Args:\n            component_id: id of the component to get data for.\n            expected_category: Category of the component to get data for.\n            transform: A method for transforming raw component data into the\n                desired output type.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            The new receiver for the given `component_id`.\n        \"\"\"\n        await self._expect_category(\n            component_id,\n            expected_category,\n        )\n\n        broadcaster = self._broadcasters.setdefault(\n            component_id,\n            streaming.GrpcStreamBroadcaster(\n                f\"raw-component-data-{component_id}\",\n                # We need to cast here because grpc says StreamComponentData is\n                # a grpc.CallIterator[PbComponentData], not a\n                # grpc.aio.UnaryStreamCall[..., PbComponentData].\n                lambda: cast(\n                    grpc.aio.UnaryStreamCall[Any, PbComponentData],\n                    self.api.StreamComponentData(PbComponentIdParam(id=component_id)),\n                ),\n                transform,\n            ),\n        )\n        return broadcaster.new_receiver(maxsize=maxsize)\n\n    async def _expect_category(\n        self,\n        component_id: int,\n        expected_category: ComponentCategory,\n    ) -&gt; None:\n        \"\"\"Check if the given component_id is of the expected type.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: Component id to check.\n            expected_category: Component category that the given id is expected\n                to have.\n        \"\"\"\n        try:\n            comp = next(\n                comp\n                for comp in await self.components()\n                if comp.component_id == component_id\n            )\n        except StopIteration as exc:\n            raise ValueError(\n                f\"Unable to find component with id {component_id}\"\n            ) from exc\n\n        if comp.category != expected_category:\n            raise ValueError(\n                f\"Component id {component_id} is a {comp.category}\"\n                f\", not a {expected_category}.\"\n            )\n\n    async def meter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[MeterData]:\n        \"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the meter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime meter data.\n        \"\"\"\n        return await self._new_component_data_receiver(\n            component_id=component_id,\n            expected_category=ComponentCategory.METER,\n            transform=MeterData.from_proto,\n            maxsize=maxsize,\n        )\n\n    async def battery_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[BatteryData]:\n        \"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the battery to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime battery data.\n        \"\"\"\n        return await self._new_component_data_receiver(\n            component_id=component_id,\n            expected_category=ComponentCategory.BATTERY,\n            transform=BatteryData.from_proto,\n            maxsize=maxsize,\n        )\n\n    async def inverter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[InverterData]:\n        \"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the inverter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime inverter data.\n        \"\"\"\n        return await self._new_component_data_receiver(\n            component_id=component_id,\n            expected_category=ComponentCategory.INVERTER,\n            transform=InverterData.from_proto,\n            maxsize=maxsize,\n        )\n\n    async def ev_charger_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[EVChargerData]:\n        \"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the ev charger to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime ev charger data.\n        \"\"\"\n        return await self._new_component_data_receiver(\n            component_id=component_id,\n            expected_category=ComponentCategory.EV_CHARGER,\n            transform=EVChargerData.from_proto,\n            maxsize=maxsize,\n        )\n\n    async def set_power(self, component_id: int, power_w: float) -&gt; None:\n        \"\"\"Send request to the Microgrid to set power for component.\n\n        If power &gt; 0, then component will be charged with this power.\n        If power &lt; 0, then component will be discharged with this power.\n        If power == 0, then stop charging or discharging component.\n\n\n        Args:\n            component_id: id of the component to set power.\n            power_w: power to set for the component.\n\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\n        try:\n            await cast(\n                Awaitable[PbSetPowerActiveParam],\n                self.api.SetPowerActive(\n                    PbSetPowerActiveParam(component_id=component_id, power=power_w),\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            )\n        except grpc.aio.AioRpcError as err:\n            msg = f\"Failed to set power. Microgrid API: {self.target}. Err: {err.details()}\"\n            raise grpc.aio.AioRpcError(\n                code=err.code(),\n                initial_metadata=err.initial_metadata(),\n                # See the comment in def components() for why we need to ignore\n                trailing_metadata=err.trailing_metadata(),  # type: ignore[arg-type]\n                details=msg,\n                debug_error_string=err.debug_error_string(),\n            )\n\n    async def set_bounds(\n        self,\n        component_id: int,\n        lower: float,\n        upper: float,\n    ) -&gt; None:\n        \"\"\"Send `PbSetBoundsParam`s received from a channel to the Microgrid service.\n\n        Args:\n            component_id: ID of the component to set bounds for.\n            lower: Lower bound to be set for the component.\n            upper: Upper bound to be set for the component.\n\n        Raises:\n            ValueError: when upper bound is less than 0, or when lower bound is\n                greater than 0.\n            grpc.aio.AioRpcError: if connection to Microgrid API cannot be established\n                or when the api call exceeded timeout\n        \"\"\"\n        api_details = f\"Microgrid API: {self.target}.\"\n        if upper &lt; 0:\n            raise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\n        if lower &gt; 0:\n            raise ValueError(f\"Lower bound {upper} must be less than or equal to 0.\")\n\n        target_metric = PbSetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE\n        try:\n            self.api.AddInclusionBounds(\n                PbSetBoundsParam(\n                    component_id=component_id,\n                    target_metric=target_metric,\n                    bounds=PbBounds(lower=lower, upper=upper),\n                ),\n            )\n        except grpc.aio.AioRpcError as err:\n            _logger.error(\n                \"set_bounds write failed: %s, for message: %s, api: %s. Err: %s\",\n                err,\n                next,\n                api_details,\n                err.details(),\n            )\n            raise\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api = MicrogridStub(grpc_channel)\n</code></pre> <p>The gRPC stub for the microgrid API.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target = target\n</code></pre> <p>The location (as \"host:port\") of the microgrid API gRPC server.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.__init__","title":"__init__","text":"<pre><code>__init__(\n    grpc_channel: Channel,\n    target: str,\n    retry_strategy: Strategy = retry.LinearBackoff(),\n) -&gt; None\n</code></pre> <p>Initialize the class instance.</p> PARAMETER  DESCRIPTION <code>grpc_channel</code> <p>asyncio-supporting gRPC channel</p> <p> TYPE: <code>Channel</code> </p> <code>target</code> <p>server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API</p> <p> TYPE: <code>str</code> </p> <code>retry_strategy</code> <p>The retry strategy to use to reconnect when the connection to the streaming method is lost.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>LinearBackoff()</code> </p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>def __init__(\n    self,\n    grpc_channel: grpc.aio.Channel,\n    target: str,\n    retry_strategy: retry.Strategy = retry.LinearBackoff(),\n) -&gt; None:\n    \"\"\"Initialize the class instance.\n\n    Args:\n        grpc_channel: asyncio-supporting gRPC channel\n        target: server (host:port) to be used for asyncio-supporting gRPC\n            channel that the client should use to contact the API\n        retry_strategy: The retry strategy to use to reconnect when the connection\n            to the streaming method is lost.\n    \"\"\"\n    self.target = target\n    \"\"\"The location (as \"host:port\") of the microgrid API gRPC server.\"\"\"\n\n    self.api = MicrogridStub(grpc_channel)\n    \"\"\"The gRPC stub for the microgrid API.\"\"\"\n\n    self._broadcasters: dict[int, streaming.GrpcStreamBroadcaster[Any, Any]] = {}\n    self._retry_strategy = retry_strategy\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.battery_data","title":"battery_data  <code>async</code>","text":"<pre><code>battery_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[BatteryData]\n</code></pre> <p>Return a channel receiver that provides a <code>BatteryData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the battery to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[BatteryData]</code> <p>A channel receiver that provides realtime battery data.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def battery_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n    \"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the battery to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime battery data.\n    \"\"\"\n    return await self._new_component_data_receiver(\n        component_id=component_id,\n        expected_category=ComponentCategory.BATTERY,\n        transform=BatteryData.from_proto,\n        maxsize=maxsize,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.components","title":"components  <code>async</code>","text":"<pre><code>components() -&gt; Iterable[Component]\n</code></pre> <p>Fetch all the components present in the microgrid.</p> RETURNS DESCRIPTION <code>Iterable[Component]</code> <p>Iterator whose elements are all the components in the microgrid.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def components(self) -&gt; Iterable[Component]:\n    \"\"\"Fetch all the components present in the microgrid.\n\n    Returns:\n        Iterator whose elements are all the components in the microgrid.\n\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\n    try:\n        # grpc.aio is missing types and mypy thinks this is not awaitable,\n        # but it is\n        component_list = await cast(\n            Awaitable[PbComponentList],\n            self.api.ListComponents(\n                PbComponentFilter(),\n                timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n            ),\n        )\n\n    except grpc.aio.AioRpcError as err:\n        msg = f\"Failed to list components. Microgrid API: {self.target}. Err: {err.details()}\"\n        raise grpc.aio.AioRpcError(\n            code=err.code(),\n            initial_metadata=err.initial_metadata(),\n            # We need to ignore these errors for some reason, otherwise we get this\n            # mypy error:\n            #   Argument \"trailing_metadata\" to \"AioRpcError\" has incompatible type\n            #   \"tuple[_Metadatum, ...]\"; expected \"Metadata\"\n            # According to grpc.aio documentation, both should have the type\n            # Metadata.\n            # https://grpc.github.io/grpc/python/grpc_asyncio.html#grpc.aio.AioRpcError\n            trailing_metadata=err.trailing_metadata(),  # type: ignore[arg-type]\n            details=msg,\n            debug_error_string=err.debug_error_string(),\n        )\n    components_only = filter(\n        lambda c: c.category is not PbComponentCategory.COMPONENT_CATEGORY_SENSOR,\n        component_list.components,\n    )\n    result: Iterable[Component] = map(\n        lambda c: Component(\n            c.id,\n            component_category_from_protobuf(c.category),\n            component_type_from_protobuf(c.category, c.inverter),\n            component_metadata_from_protobuf(c.category, c.grid),\n        ),\n        components_only,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.connections","title":"connections  <code>async</code>","text":"<pre><code>connections(\n    starts: set[int] | None = None,\n    ends: set[int] | None = None,\n) -&gt; Iterable[Connection]\n</code></pre> <p>Fetch the connections between components in the microgrid.</p> PARAMETER  DESCRIPTION <code>starts</code> <p>if set and non-empty, only include connections whose start value matches one of the provided component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>ends</code> <p>if set and non-empty, only include connections whose end value matches one of the provided component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Connection]</code> <p>Microgrid connections matching the provided start and end filters.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def connections(\n    self,\n    starts: set[int] | None = None,\n    ends: set[int] | None = None,\n) -&gt; Iterable[Connection]:\n    \"\"\"Fetch the connections between components in the microgrid.\n\n    Args:\n        starts: if set and non-empty, only include connections whose start\n            value matches one of the provided component IDs\n        ends: if set and non-empty, only include connections whose end value\n            matches one of the provided component IDs\n\n    Returns:\n        Microgrid connections matching the provided start and end filters.\n\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\n    connection_filter = PbConnectionFilter(starts=starts, ends=ends)\n    try:\n        valid_components, all_connections = await asyncio.gather(\n            self.components(),\n            # grpc.aio is missing types and mypy thinks this is not\n            # awaitable, but it is\n            cast(\n                Awaitable[PbConnectionList],\n                self.api.ListConnections(\n                    connection_filter,\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            ),\n        )\n    except grpc.aio.AioRpcError as err:\n        msg = f\"Failed to list connections. Microgrid API: {self.target}. Err: {err.details()}\"\n        raise grpc.aio.AioRpcError(\n            code=err.code(),\n            initial_metadata=err.initial_metadata(),\n            # See the comment in def components() for why we need to ignore\n            trailing_metadata=err.trailing_metadata(),  # type: ignore[arg-type]\n            details=msg,\n            debug_error_string=err.debug_error_string(),\n        )\n    # Filter out the components filtered in `components` method.\n    # id=0 is an exception indicating grid component.\n    valid_ids = {c.component_id for c in valid_components}\n    valid_ids.add(0)\n\n    connections = filter(\n        lambda c: (c.start in valid_ids and c.end in valid_ids),\n        all_connections.connections,\n    )\n\n    result: Iterable[Connection] = map(\n        lambda c: Connection(c.start, c.end), connections\n    )\n\n    return result\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.ev_charger_data","title":"ev_charger_data  <code>async</code>","text":"<pre><code>ev_charger_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[EVChargerData]\n</code></pre> <p>Return a channel receiver that provides an <code>EvChargeData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the ev charger to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A channel receiver that provides realtime ev charger data.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def ev_charger_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n    \"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the ev charger to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime ev charger data.\n    \"\"\"\n    return await self._new_component_data_receiver(\n        component_id=component_id,\n        expected_category=ComponentCategory.EV_CHARGER,\n        transform=EVChargerData.from_proto,\n        maxsize=maxsize,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.inverter_data","title":"inverter_data  <code>async</code>","text":"<pre><code>inverter_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[InverterData]\n</code></pre> <p>Return a channel receiver that provides an <code>InverterData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the inverter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[InverterData]</code> <p>A channel receiver that provides realtime inverter data.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def inverter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n    \"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the inverter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime inverter data.\n    \"\"\"\n    return await self._new_component_data_receiver(\n        component_id=component_id,\n        expected_category=ComponentCategory.INVERTER,\n        transform=InverterData.from_proto,\n        maxsize=maxsize,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.metadata","title":"metadata  <code>async</code>","text":"<pre><code>metadata() -&gt; Metadata\n</code></pre> <p>Fetch the microgrid metadata.</p> <p>If there is an error fetching the metadata, the microgrid ID and location will be set to None.</p> RETURNS DESCRIPTION <code>Metadata</code> <p>the microgrid metadata.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def metadata(self) -&gt; Metadata:\n    \"\"\"Fetch the microgrid metadata.\n\n    If there is an error fetching the metadata, the microgrid ID and\n    location will be set to None.\n\n    Returns:\n        the microgrid metadata.\n    \"\"\"\n    microgrid_metadata: PbMicrogridMetadata | None = None\n    try:\n        microgrid_metadata = await cast(\n            Awaitable[PbMicrogridMetadata],\n            self.api.GetMicrogridMetadata(\n                Empty(),\n                timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n            ),\n        )\n    except grpc.aio.AioRpcError:\n        _logger.exception(\"The microgrid metadata is not available.\")\n\n    if not microgrid_metadata:\n        return Metadata()\n\n    location: Location | None = None\n    if microgrid_metadata.location:\n        location = Location(\n            latitude=microgrid_metadata.location.latitude,\n            longitude=microgrid_metadata.location.longitude,\n        )\n\n    return Metadata(microgrid_id=microgrid_metadata.microgrid_id, location=location)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.meter_data","title":"meter_data  <code>async</code>","text":"<pre><code>meter_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[MeterData]\n</code></pre> <p>Return a channel receiver that provides a <code>MeterData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the meter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[MeterData]</code> <p>A channel receiver that provides realtime meter data.</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def meter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n    \"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the meter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime meter data.\n    \"\"\"\n    return await self._new_component_data_receiver(\n        component_id=component_id,\n        expected_category=ComponentCategory.METER,\n        transform=MeterData.from_proto,\n        maxsize=maxsize,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.set_bounds","title":"set_bounds  <code>async</code>","text":"<pre><code>set_bounds(\n    component_id: int, lower: float, upper: float\n) -&gt; None\n</code></pre> <p>Send <code>PbSetBoundsParam</code>s received from a channel to the Microgrid service.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>ID of the component to set bounds for.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>Lower bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> <code>upper</code> <p>Upper bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>when upper bound is less than 0, or when lower bound is greater than 0.</p> <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def set_bounds(\n    self,\n    component_id: int,\n    lower: float,\n    upper: float,\n) -&gt; None:\n    \"\"\"Send `PbSetBoundsParam`s received from a channel to the Microgrid service.\n\n    Args:\n        component_id: ID of the component to set bounds for.\n        lower: Lower bound to be set for the component.\n        upper: Upper bound to be set for the component.\n\n    Raises:\n        ValueError: when upper bound is less than 0, or when lower bound is\n            greater than 0.\n        grpc.aio.AioRpcError: if connection to Microgrid API cannot be established\n            or when the api call exceeded timeout\n    \"\"\"\n    api_details = f\"Microgrid API: {self.target}.\"\n    if upper &lt; 0:\n        raise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\n    if lower &gt; 0:\n        raise ValueError(f\"Lower bound {upper} must be less than or equal to 0.\")\n\n    target_metric = PbSetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE\n    try:\n        self.api.AddInclusionBounds(\n            PbSetBoundsParam(\n                component_id=component_id,\n                target_metric=target_metric,\n                bounds=PbBounds(lower=lower, upper=upper),\n            ),\n        )\n    except grpc.aio.AioRpcError as err:\n        _logger.error(\n            \"set_bounds write failed: %s, for message: %s, api: %s. Err: %s\",\n            err,\n            next,\n            api_details,\n            err.details(),\n        )\n        raise\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ApiClient.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(component_id: int, power_w: float) -&gt; None\n</code></pre> <p>Send request to the Microgrid to set power for component.</p> <p>If power &gt; 0, then component will be charged with this power. If power &lt; 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the component to set power.</p> <p> TYPE: <code>int</code> </p> <code>power_w</code> <p>power to set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/client/microgrid/_client.py</code> <pre><code>async def set_power(self, component_id: int, power_w: float) -&gt; None:\n    \"\"\"Send request to the Microgrid to set power for component.\n\n    If power &gt; 0, then component will be charged with this power.\n    If power &lt; 0, then component will be discharged with this power.\n    If power == 0, then stop charging or discharging component.\n\n\n    Args:\n        component_id: id of the component to set power.\n        power_w: power to set for the component.\n\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\n    try:\n        await cast(\n            Awaitable[PbSetPowerActiveParam],\n            self.api.SetPowerActive(\n                PbSetPowerActiveParam(component_id=component_id, power=power_w),\n                timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n            ),\n        )\n    except grpc.aio.AioRpcError as err:\n        msg = f\"Failed to set power. Microgrid API: {self.target}. Err: {err.details()}\"\n        raise grpc.aio.AioRpcError(\n            code=err.code(),\n            initial_metadata=err.initial_metadata(),\n            # See the comment in def components() for why we need to ignore\n            trailing_metadata=err.trailing_metadata(),  # type: ignore[arg-type]\n            details=msg,\n            debug_error_string=err.debug_error_string(),\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData","title":"frequenz.client.microgrid.BatteryData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding battery data.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass BatteryData(ComponentData):  # pylint: disable=too-many-instance-attributes\n    \"\"\"A wrapper class for holding battery data.\"\"\"\n\n    soc: float\n    \"\"\"Battery's overall SoC in percent (%).\"\"\"\n\n    soc_lower_bound: float\n    \"\"\"The SoC below which discharge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\n\n    soc_upper_bound: float\n    \"\"\"The SoC above which charge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\n\n    capacity: float\n    \"\"\"The capacity of the battery in Wh (Watt-hour).\"\"\"\n\n    # pylint: disable=line-too-long\n    power_inclusion_lower_bound: float\n    \"\"\"Lower inclusion bound for battery power in watts.\n\n    This is the lower limit of the range within which power requests are allowed for the\n    battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    power_exclusion_lower_bound: float\n    \"\"\"Lower exclusion bound for battery power in watts.\n\n    This is the lower limit of the range within which power requests are not allowed for\n    the battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    power_inclusion_upper_bound: float\n    \"\"\"Upper inclusion bound for battery power in watts.\n\n    This is the upper limit of the range within which power requests are allowed for the\n    battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    power_exclusion_upper_bound: float\n    \"\"\"Upper exclusion bound for battery power in watts.\n\n    This is the upper limit of the range within which power requests are not allowed for\n    the battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n    # pylint: enable=line-too-long\n\n    temperature: float\n    \"\"\"The (average) temperature reported by the battery, in Celsius (\u00b0C).\"\"\"\n\n    _relay_state: PbBatteryRelayState.ValueType\n    \"\"\"State of the battery relay.\"\"\"\n\n    _component_state: PbBatteryComponentState.ValueType\n    \"\"\"State of the battery.\"\"\"\n\n    _errors: list[PbBatteryError]\n    \"\"\"List of errors in protobuf struct.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: PbComponentData) -&gt; Self:\n        \"\"\"Create BatteryData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of BatteryData created from the protobuf message.\n        \"\"\"\n        raw_power = raw.battery.data.dc.power\n        battery_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            soc=raw.battery.data.soc.avg,\n            soc_lower_bound=raw.battery.data.soc.system_inclusion_bounds.lower,\n            soc_upper_bound=raw.battery.data.soc.system_inclusion_bounds.upper,\n            capacity=raw.battery.properties.capacity,\n            power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n            power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n            power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n            power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n            temperature=raw.battery.data.temperature.avg,\n            _relay_state=raw.battery.state.relay_state,\n            _component_state=raw.battery.state.component_state,\n            _errors=list(raw.battery.errors),\n        )\n        battery_data._set_raw(raw=raw)\n        return battery_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.capacity","title":"capacity  <code>instance-attribute</code>","text":"<pre><code>capacity: float\n</code></pre> <p>The capacity of the battery in Wh (Watt-hour).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.power_exclusion_lower_bound","title":"power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for battery power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.power_exclusion_upper_bound","title":"power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for battery power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.power_inclusion_lower_bound","title":"power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for battery power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.power_inclusion_upper_bound","title":"power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for battery power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.soc","title":"soc  <code>instance-attribute</code>","text":"<pre><code>soc: float\n</code></pre> <p>Battery's overall SoC in percent (%).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.soc_lower_bound","title":"soc_lower_bound  <code>instance-attribute</code>","text":"<pre><code>soc_lower_bound: float\n</code></pre> <p>The SoC below which discharge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.soc_upper_bound","title":"soc_upper_bound  <code>instance-attribute</code>","text":"<pre><code>soc_upper_bound: float\n</code></pre> <p>The SoC above which charge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature: float\n</code></pre> <p>The (average) temperature reported by the battery, in Celsius (\u00b0C).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.BatteryData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; Self\n</code></pre> <p>Create BatteryData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Instance of BatteryData created from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: PbComponentData) -&gt; Self:\n    \"\"\"Create BatteryData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of BatteryData created from the protobuf message.\n    \"\"\"\n    raw_power = raw.battery.data.dc.power\n    battery_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        soc=raw.battery.data.soc.avg,\n        soc_lower_bound=raw.battery.data.soc.system_inclusion_bounds.lower,\n        soc_upper_bound=raw.battery.data.soc.system_inclusion_bounds.upper,\n        capacity=raw.battery.properties.capacity,\n        power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n        power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n        power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n        power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n        temperature=raw.battery.data.temperature.avg,\n        _relay_state=raw.battery.state.relay_state,\n        _component_state=raw.battery.state.component_state,\n        _errors=list(raw.battery.errors),\n    )\n    battery_data._set_raw(raw=raw)\n    return battery_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component","title":"frequenz.client.microgrid.Component  <code>dataclass</code>","text":"<p>Metadata for a single microgrid component.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass Component:\n    \"\"\"Metadata for a single microgrid component.\"\"\"\n\n    component_id: int\n    \"\"\"The ID of this component.\"\"\"\n\n    category: ComponentCategory\n    \"\"\"The category of this component.\"\"\"\n\n    type: ComponentType | None = None\n    \"\"\"The type of this component.\"\"\"\n\n    metadata: ComponentMetadata | None = None\n    \"\"\"The metadata of this component.\"\"\"\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Check if this instance contains valid data.\n\n        Returns:\n            `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n                == 0` and `type` is `GRID`, `False` otherwise\n        \"\"\"\n        return (\n            self.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n        ) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute a hash of this instance, obtained by hashing the `component_id` field.\n\n        Returns:\n            Hash of this instance.\n        \"\"\"\n        return hash(self.component_id)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: ComponentCategory\n</code></pre> <p>The category of this component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID of this component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: ComponentMetadata | None = None\n</code></pre> <p>The metadata of this component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: ComponentType | None = None\n</code></pre> <p>The type of this component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Compute a hash of this instance, obtained by hashing the <code>component_id</code> field.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of this instance.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Compute a hash of this instance, obtained by hashing the `component_id` field.\n\n    Returns:\n        Hash of this instance.\n    \"\"\"\n    return hash(self.component_id)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Component.is_valid","title":"is_valid","text":"<pre><code>is_valid() -&gt; bool\n</code></pre> <p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>id &gt; 0</code> and <code>type</code> is a valid <code>ComponentCategory</code>, or if <code>id == 0</code> and <code>type</code> is <code>GRID</code>, <code>False</code> otherwise</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"Check if this instance contains valid data.\n\n    Returns:\n        `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n            == 0` and `type` is `GRID`, `False` otherwise\n    \"\"\"\n    return (\n        self.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n    ) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory","title":"frequenz.client.microgrid.ComponentCategory","text":"<p>             Bases: <code>Enum</code></p> <p>Possible types of microgrid component.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>class ComponentCategory(Enum):\n    \"\"\"Possible types of microgrid component.\"\"\"\n\n    NONE = PbComponentCategory.COMPONENT_CATEGORY_UNSPECIFIED\n    \"\"\"Unspecified component category.\"\"\"\n\n    GRID = PbComponentCategory.COMPONENT_CATEGORY_GRID\n    \"\"\"Grid component.\"\"\"\n\n    METER = PbComponentCategory.COMPONENT_CATEGORY_METER\n    \"\"\"Meter component.\"\"\"\n\n    INVERTER = PbComponentCategory.COMPONENT_CATEGORY_INVERTER\n    \"\"\"Inverter component.\"\"\"\n\n    BATTERY = PbComponentCategory.COMPONENT_CATEGORY_BATTERY\n    \"\"\"Battery component.\"\"\"\n\n    EV_CHARGER = PbComponentCategory.COMPONENT_CATEGORY_EV_CHARGER\n    \"\"\"EV charger component.\"\"\"\n\n    CHP = PbComponentCategory.COMPONENT_CATEGORY_CHP\n    \"\"\"CHP component.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.BATTERY","title":"BATTERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY = COMPONENT_CATEGORY_BATTERY\n</code></pre> <p>Battery component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.CHP","title":"CHP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHP = COMPONENT_CATEGORY_CHP\n</code></pre> <p>CHP component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.EV_CHARGER","title":"EV_CHARGER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_CHARGER = COMPONENT_CATEGORY_EV_CHARGER\n</code></pre> <p>EV charger component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.GRID","title":"GRID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GRID = COMPONENT_CATEGORY_GRID\n</code></pre> <p>Grid component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.INVERTER","title":"INVERTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INVERTER = COMPONENT_CATEGORY_INVERTER\n</code></pre> <p>Inverter component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.METER","title":"METER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METER = COMPONENT_CATEGORY_METER\n</code></pre> <p>Meter component.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentCategory.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = COMPONENT_CATEGORY_UNSPECIFIED\n</code></pre> <p>Unspecified component category.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData","title":"frequenz.client.microgrid.ComponentData  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A private base class for strongly typed component data classes.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentData(ABC):\n    \"\"\"A private base class for strongly typed component data classes.\"\"\"\n\n    component_id: int\n    \"\"\"The ID identifying this component in the microgrid.\"\"\"\n\n    timestamp: datetime\n    \"\"\"The timestamp of when the data was measured.\"\"\"\n\n    # The `raw` attribute is excluded from the constructor as it can only be provided\n    # when instantiating `ComponentData` using the `from_proto` method, which reads\n    # data from a protobuf message. The whole protobuf message is stored as the `raw`\n    # attribute. When `ComponentData` is not instantiated from a protobuf message,\n    # i.e. using the constructor, `raw` will be set to `None`.\n    raw: PbComponentData | None = field(default=None, init=False)\n    \"\"\"Raw component data as decoded from the wire.\"\"\"\n\n    def _set_raw(self, raw: PbComponentData) -&gt; None:\n        \"\"\"Store raw protobuf message.\n\n        It is preferred to keep the dataclasses immutable (frozen) and make the `raw`\n            attribute read-only, which is why the approach of writing to `__dict__`\n            was used, instead of mutating the `self.raw = raw` attribute directly.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n        \"\"\"\n        self.__dict__[\"raw\"] = raw\n\n    @classmethod\n    @abstractmethod\n    def from_proto(cls, raw: PbComponentData) -&gt; Self:\n        \"\"\"Create ComponentData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            The instance created from the protobuf message.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentData.from_proto","title":"from_proto  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; Self\n</code></pre> <p>Create ComponentData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The instance created from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_proto(cls, raw: PbComponentData) -&gt; Self:\n    \"\"\"Create ComponentData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        The instance created from the protobuf message.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetadata","title":"frequenz.client.microgrid.ComponentMetadata  <code>dataclass</code>","text":"<p>Base class for component metadata classes.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentMetadata:\n    \"\"\"Base class for component metadata classes.\"\"\"\n\n    fuse: Fuse | None = None\n    \"\"\"The fuse at the grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetadata.fuse","title":"fuse  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuse: Fuse | None = None\n</code></pre> <p>The fuse at the grid connection point.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId","title":"frequenz.client.microgrid.ComponentMetricId","text":"<p>             Bases: <code>Enum</code></p> <p>An enum representing the various metrics available in the microgrid.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>class ComponentMetricId(Enum):\n    \"\"\"An enum representing the various metrics available in the microgrid.\"\"\"\n\n    ACTIVE_POWER = \"active_power\"\n    \"\"\"Active power.\"\"\"\n\n    ACTIVE_POWER_PHASE_1 = \"active_power_phase_1\"\n    \"\"\"Active power in phase 1.\"\"\"\n    ACTIVE_POWER_PHASE_2 = \"active_power_phase_2\"\n    \"\"\"Active power in phase 2.\"\"\"\n    ACTIVE_POWER_PHASE_3 = \"active_power_phase_3\"\n    \"\"\"Active power in phase 3.\"\"\"\n\n    REACTIVE_POWER = \"reactive_power\"\n    \"\"\"Reactive power.\"\"\"\n\n    REACTIVE_POWER_PHASE_1 = \"reactive_power_phase_1\"\n    \"\"\"Reactive power in phase 1.\"\"\"\n    REACTIVE_POWER_PHASE_2 = \"reactive_power_phase_2\"\n    \"\"\"Reactive power in phase 2.\"\"\"\n    REACTIVE_POWER_PHASE_3 = \"reactive_power_phase_3\"\n    \"\"\"Reactive power in phase 3.\"\"\"\n\n    CURRENT_PHASE_1 = \"current_phase_1\"\n    \"\"\"Current in phase 1.\"\"\"\n    CURRENT_PHASE_2 = \"current_phase_2\"\n    \"\"\"Current in phase 2.\"\"\"\n    CURRENT_PHASE_3 = \"current_phase_3\"\n    \"\"\"Current in phase 3.\"\"\"\n\n    VOLTAGE_PHASE_1 = \"voltage_phase_1\"\n    \"\"\"Voltage in phase 1.\"\"\"\n    VOLTAGE_PHASE_2 = \"voltage_phase_2\"\n    \"\"\"Voltage in phase 2.\"\"\"\n    VOLTAGE_PHASE_3 = \"voltage_phase_3\"\n    \"\"\"Voltage in phase 3.\"\"\"\n\n    FREQUENCY = \"frequency\"\n\n    SOC = \"soc\"\n    \"\"\"State of charge.\"\"\"\n    SOC_LOWER_BOUND = \"soc_lower_bound\"\n    \"\"\"Lower bound of state of charge.\"\"\"\n    SOC_UPPER_BOUND = \"soc_upper_bound\"\n    \"\"\"Upper bound of state of charge.\"\"\"\n    CAPACITY = \"capacity\"\n    \"\"\"Capacity.\"\"\"\n\n    POWER_INCLUSION_LOWER_BOUND = \"power_inclusion_lower_bound\"\n    \"\"\"Power inclusion lower bound.\"\"\"\n    POWER_EXCLUSION_LOWER_BOUND = \"power_exclusion_lower_bound\"\n    \"\"\"Power exclusion lower bound.\"\"\"\n    POWER_EXCLUSION_UPPER_BOUND = \"power_exclusion_upper_bound\"\n    \"\"\"Power exclusion upper bound.\"\"\"\n    POWER_INCLUSION_UPPER_BOUND = \"power_inclusion_upper_bound\"\n    \"\"\"Power inclusion upper bound.\"\"\"\n\n    ACTIVE_POWER_INCLUSION_LOWER_BOUND = \"active_power_inclusion_lower_bound\"\n    \"\"\"Active power inclusion lower bound.\"\"\"\n    ACTIVE_POWER_EXCLUSION_LOWER_BOUND = \"active_power_exclusion_lower_bound\"\n    \"\"\"Active power exclusion lower bound.\"\"\"\n    ACTIVE_POWER_EXCLUSION_UPPER_BOUND = \"active_power_exclusion_upper_bound\"\n    \"\"\"Active power exclusion upper bound.\"\"\"\n    ACTIVE_POWER_INCLUSION_UPPER_BOUND = \"active_power_inclusion_upper_bound\"\n    \"\"\"Active power inclusion upper bound.\"\"\"\n\n    TEMPERATURE = \"temperature\"\n    \"\"\"Temperature.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER","title":"ACTIVE_POWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER = 'active_power'\n</code></pre> <p>Active power.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_EXCLUSION_LOWER_BOUND","title":"ACTIVE_POWER_EXCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_EXCLUSION_LOWER_BOUND = (\n    \"active_power_exclusion_lower_bound\"\n)\n</code></pre> <p>Active power exclusion lower bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_EXCLUSION_UPPER_BOUND","title":"ACTIVE_POWER_EXCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_EXCLUSION_UPPER_BOUND = (\n    \"active_power_exclusion_upper_bound\"\n)\n</code></pre> <p>Active power exclusion upper bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_INCLUSION_LOWER_BOUND","title":"ACTIVE_POWER_INCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_INCLUSION_LOWER_BOUND = (\n    \"active_power_inclusion_lower_bound\"\n)\n</code></pre> <p>Active power inclusion lower bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_INCLUSION_UPPER_BOUND","title":"ACTIVE_POWER_INCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_INCLUSION_UPPER_BOUND = (\n    \"active_power_inclusion_upper_bound\"\n)\n</code></pre> <p>Active power inclusion upper bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_PHASE_1","title":"ACTIVE_POWER_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_PHASE_1 = 'active_power_phase_1'\n</code></pre> <p>Active power in phase 1.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_PHASE_2","title":"ACTIVE_POWER_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_PHASE_2 = 'active_power_phase_2'\n</code></pre> <p>Active power in phase 2.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.ACTIVE_POWER_PHASE_3","title":"ACTIVE_POWER_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_PHASE_3 = 'active_power_phase_3'\n</code></pre> <p>Active power in phase 3.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.CAPACITY","title":"CAPACITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CAPACITY = 'capacity'\n</code></pre> <p>Capacity.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.CURRENT_PHASE_1","title":"CURRENT_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_1 = 'current_phase_1'\n</code></pre> <p>Current in phase 1.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.CURRENT_PHASE_2","title":"CURRENT_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_2 = 'current_phase_2'\n</code></pre> <p>Current in phase 2.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.CURRENT_PHASE_3","title":"CURRENT_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_3 = 'current_phase_3'\n</code></pre> <p>Current in phase 3.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.POWER_EXCLUSION_LOWER_BOUND","title":"POWER_EXCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_EXCLUSION_LOWER_BOUND = 'power_exclusion_lower_bound'\n</code></pre> <p>Power exclusion lower bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.POWER_EXCLUSION_UPPER_BOUND","title":"POWER_EXCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_EXCLUSION_UPPER_BOUND = 'power_exclusion_upper_bound'\n</code></pre> <p>Power exclusion upper bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.POWER_INCLUSION_LOWER_BOUND","title":"POWER_INCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_INCLUSION_LOWER_BOUND = 'power_inclusion_lower_bound'\n</code></pre> <p>Power inclusion lower bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.POWER_INCLUSION_UPPER_BOUND","title":"POWER_INCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_INCLUSION_UPPER_BOUND = 'power_inclusion_upper_bound'\n</code></pre> <p>Power inclusion upper bound.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.REACTIVE_POWER","title":"REACTIVE_POWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REACTIVE_POWER = 'reactive_power'\n</code></pre> <p>Reactive power.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.REACTIVE_POWER_PHASE_1","title":"REACTIVE_POWER_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REACTIVE_POWER_PHASE_1 = 'reactive_power_phase_1'\n</code></pre> <p>Reactive power in phase 1.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.REACTIVE_POWER_PHASE_2","title":"REACTIVE_POWER_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REACTIVE_POWER_PHASE_2 = 'reactive_power_phase_2'\n</code></pre> <p>Reactive power in phase 2.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.REACTIVE_POWER_PHASE_3","title":"REACTIVE_POWER_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REACTIVE_POWER_PHASE_3 = 'reactive_power_phase_3'\n</code></pre> <p>Reactive power in phase 3.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.SOC","title":"SOC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC = 'soc'\n</code></pre> <p>State of charge.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.SOC_LOWER_BOUND","title":"SOC_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC_LOWER_BOUND = 'soc_lower_bound'\n</code></pre> <p>Lower bound of state of charge.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.SOC_UPPER_BOUND","title":"SOC_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC_UPPER_BOUND = 'soc_upper_bound'\n</code></pre> <p>Upper bound of state of charge.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.TEMPERATURE","title":"TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEMPERATURE = 'temperature'\n</code></pre> <p>Temperature.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.VOLTAGE_PHASE_1","title":"VOLTAGE_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_1 = 'voltage_phase_1'\n</code></pre> <p>Voltage in phase 1.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.VOLTAGE_PHASE_2","title":"VOLTAGE_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_2 = 'voltage_phase_2'\n</code></pre> <p>Voltage in phase 2.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentMetricId.VOLTAGE_PHASE_3","title":"VOLTAGE_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_3 = 'voltage_phase_3'\n</code></pre> <p>Voltage in phase 3.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.ComponentType","title":"frequenz.client.microgrid.ComponentType","text":"<p>             Bases: <code>Enum</code></p> <p>A base class from which individual component types are derived.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>class ComponentType(Enum):\n    \"\"\"A base class from which individual component types are derived.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection","title":"frequenz.client.microgrid.Connection  <code>dataclass</code>","text":"<p>Metadata for a connection between microgrid components.</p> Source code in <code>frequenz/client/microgrid/_connection.py</code> <pre><code>@dataclass(frozen=True)\nclass Connection:\n    \"\"\"Metadata for a connection between microgrid components.\"\"\"\n\n    start: int\n    \"\"\"The component ID that represents the start component of the connection.\"\"\"\n\n    end: int\n    \"\"\"The component ID that represents the end component of the connection.\"\"\"\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Check if this instance contains valid data.\n\n        Returns:\n            `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n                otherwise.\n        \"\"\"\n        return self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection.end","title":"end  <code>instance-attribute</code>","text":"<pre><code>end: int\n</code></pre> <p>The component ID that represents the end component of the connection.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: int\n</code></pre> <p>The component ID that represents the start component of the connection.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Connection.is_valid","title":"is_valid","text":"<pre><code>is_valid() -&gt; bool\n</code></pre> <p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>start &gt;= 0</code>, <code>end &gt; 0</code>, and <code>start != end</code>, <code>False</code> otherwise.</p> Source code in <code>frequenz/client/microgrid/_connection.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"Check if this instance contains valid data.\n\n    Returns:\n        `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n            otherwise.\n    \"\"\"\n    return self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState","title":"frequenz.client.microgrid.EVChargerCableState","text":"<p>             Bases: <code>Enum</code></p> <p>Cable states of an EV Charger.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>class EVChargerCableState(Enum):\n    \"\"\"Cable states of an EV Charger.\"\"\"\n\n    UNSPECIFIED = PbCableState.CABLE_STATE_UNSPECIFIED\n    \"\"\"Unspecified cable state.\"\"\"\n\n    UNPLUGGED = PbCableState.CABLE_STATE_UNPLUGGED\n    \"\"\"The cable is unplugged.\"\"\"\n\n    CHARGING_STATION_PLUGGED = PbCableState.CABLE_STATE_CHARGING_STATION_PLUGGED\n    \"\"\"The cable is plugged into the charging station.\"\"\"\n\n    CHARGING_STATION_LOCKED = PbCableState.CABLE_STATE_CHARGING_STATION_LOCKED\n    \"\"\"The cable is plugged into the charging station and locked.\"\"\"\n\n    EV_PLUGGED = PbCableState.CABLE_STATE_EV_PLUGGED\n    \"\"\"The cable is plugged into the EV.\"\"\"\n\n    EV_LOCKED = PbCableState.CABLE_STATE_EV_LOCKED\n    \"\"\"The cable is plugged into the EV and locked.\"\"\"\n\n    @classmethod\n    def from_pb(cls, evc_state: PbCableState.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf CableState value to EVChargerCableState enum.\n\n        Args:\n            evc_state: protobuf cable state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(t.value == evc_state for t in EVChargerCableState):\n            return cls(cls.UNSPECIFIED)\n\n        return cls(evc_state)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.CHARGING_STATION_LOCKED","title":"CHARGING_STATION_LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING_STATION_LOCKED = (\n    CABLE_STATE_CHARGING_STATION_LOCKED\n)\n</code></pre> <p>The cable is plugged into the charging station and locked.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.CHARGING_STATION_PLUGGED","title":"CHARGING_STATION_PLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING_STATION_PLUGGED = (\n    CABLE_STATE_CHARGING_STATION_PLUGGED\n)\n</code></pre> <p>The cable is plugged into the charging station.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.EV_LOCKED","title":"EV_LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_LOCKED = CABLE_STATE_EV_LOCKED\n</code></pre> <p>The cable is plugged into the EV and locked.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.EV_PLUGGED","title":"EV_PLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_PLUGGED = CABLE_STATE_EV_PLUGGED\n</code></pre> <p>The cable is plugged into the EV.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.UNPLUGGED","title":"UNPLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNPLUGGED = CABLE_STATE_UNPLUGGED\n</code></pre> <p>The cable is unplugged.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = CABLE_STATE_UNSPECIFIED\n</code></pre> <p>Unspecified cable state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerCableState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(evc_state: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf CableState value to EVChargerCableState enum.</p> PARAMETER  DESCRIPTION <code>evc_state</code> <p>protobuf cable state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(cls, evc_state: PbCableState.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf CableState value to EVChargerCableState enum.\n\n    Args:\n        evc_state: protobuf cable state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(t.value == evc_state for t in EVChargerCableState):\n        return cls(cls.UNSPECIFIED)\n\n    return cls(evc_state)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState","title":"frequenz.client.microgrid.EVChargerComponentState","text":"<p>             Bases: <code>Enum</code></p> <p>Component State of an EV Charger.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>class EVChargerComponentState(Enum):\n    \"\"\"Component State of an EV Charger.\"\"\"\n\n    UNSPECIFIED = PbComponentState.COMPONENT_STATE_UNSPECIFIED\n    \"\"\"Unspecified component state.\"\"\"\n\n    STARTING = PbComponentState.COMPONENT_STATE_STARTING\n    \"\"\"The component is starting.\"\"\"\n\n    NOT_READY = PbComponentState.COMPONENT_STATE_NOT_READY\n    \"\"\"The component is not ready.\"\"\"\n\n    READY = PbComponentState.COMPONENT_STATE_READY\n    \"\"\"The component is ready.\"\"\"\n\n    CHARGING = PbComponentState.COMPONENT_STATE_CHARGING\n    \"\"\"The component is charging.\"\"\"\n\n    DISCHARGING = PbComponentState.COMPONENT_STATE_DISCHARGING\n    \"\"\"The component is discharging.\"\"\"\n\n    ERROR = PbComponentState.COMPONENT_STATE_ERROR\n    \"\"\"The component is in error state.\"\"\"\n\n    AUTHORIZATION_REJECTED = PbComponentState.COMPONENT_STATE_AUTHORIZATION_REJECTED\n    \"\"\"The component rejected authorization.\"\"\"\n\n    INTERRUPTED = PbComponentState.COMPONENT_STATE_INTERRUPTED\n    \"\"\"The component is interrupted.\"\"\"\n\n    @classmethod\n    def from_pb(cls, evc_state: PbComponentState.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum.\n\n        Args:\n            evc_state: protobuf component state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(t.value == evc_state for t in EVChargerComponentState):\n            return cls(cls.UNSPECIFIED)\n\n        return cls(evc_state)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.AUTHORIZATION_REJECTED","title":"AUTHORIZATION_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTHORIZATION_REJECTED = (\n    COMPONENT_STATE_AUTHORIZATION_REJECTED\n)\n</code></pre> <p>The component rejected authorization.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.CHARGING","title":"CHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING = COMPONENT_STATE_CHARGING\n</code></pre> <p>The component is charging.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.DISCHARGING","title":"DISCHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISCHARGING = COMPONENT_STATE_DISCHARGING\n</code></pre> <p>The component is discharging.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = COMPONENT_STATE_ERROR\n</code></pre> <p>The component is in error state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.INTERRUPTED","title":"INTERRUPTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERRUPTED = COMPONENT_STATE_INTERRUPTED\n</code></pre> <p>The component is interrupted.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.NOT_READY","title":"NOT_READY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_READY = COMPONENT_STATE_NOT_READY\n</code></pre> <p>The component is not ready.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.READY","title":"READY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>READY = COMPONENT_STATE_READY\n</code></pre> <p>The component is ready.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.STARTING","title":"STARTING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STARTING = COMPONENT_STATE_STARTING\n</code></pre> <p>The component is starting.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = COMPONENT_STATE_UNSPECIFIED\n</code></pre> <p>Unspecified component state.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerComponentState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(evc_state: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf ComponentState value to EVChargerComponentState enum.</p> PARAMETER  DESCRIPTION <code>evc_state</code> <p>protobuf component state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(cls, evc_state: PbComponentState.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum.\n\n    Args:\n        evc_state: protobuf component state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(t.value == evc_state for t in EVChargerComponentState):\n        return cls(cls.UNSPECIFIED)\n\n    return cls(evc_state)\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData","title":"frequenz.client.microgrid.EVChargerData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding ev_charger data.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass EVChargerData(ComponentData):  # pylint: disable=too-many-instance-attributes\n    \"\"\"A wrapper class for holding ev_charger data.\"\"\"\n\n    active_power: float\n    \"\"\"The total active 3-phase AC power, in Watts (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    active_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    current_per_phase: tuple[float, float, float]\n    \"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    reactive_power: float\n    \"\"\"The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    reactive_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).\n\n    The provided values are for phase 1, 2, and 3 respectively.\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    voltage_per_phase: tuple[float, float, float]\n    \"\"\"The AC voltage in Volts (V) between the line and the neutral\n        wire for phase/line 1,2 and 3 respectively.\n    \"\"\"\n\n    active_power_inclusion_lower_bound: float\n    \"\"\"Lower inclusion bound for EV charger power in watts.\n\n    This is the lower limit of the range within which power requests are allowed for the\n    EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_lower_bound: float\n    \"\"\"Lower exclusion bound for EV charger power in watts.\n\n    This is the lower limit of the range within which power requests are not allowed for\n    the EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_inclusion_upper_bound: float\n    \"\"\"Upper inclusion bound for EV charger power in watts.\n\n    This is the upper limit of the range within which power requests are allowed for the\n    EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_upper_bound: float\n    \"\"\"Upper exclusion bound for EV charger power in watts.\n\n    This is the upper limit of the range within which power requests are not allowed for\n    the EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    frequency: float\n    \"\"\"AC frequency, in Hertz (Hz).\"\"\"\n\n    cable_state: EVChargerCableState\n    \"\"\"The state of the ev charger's cable.\"\"\"\n\n    component_state: EVChargerComponentState\n    \"\"\"The state of the ev charger.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: PbComponentData) -&gt; Self:\n        \"\"\"Create EVChargerData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of EVChargerData created from the protobuf message.\n        \"\"\"\n        raw_power = raw.ev_charger.data.ac.power_active\n        ev_charger_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw_power.value,\n            active_power_per_phase=(\n                raw.ev_charger.data.ac.phase_1.power_active.value,\n                raw.ev_charger.data.ac.phase_2.power_active.value,\n                raw.ev_charger.data.ac.phase_3.power_active.value,\n            ),\n            reactive_power=raw.ev_charger.data.ac.power_reactive.value,\n            reactive_power_per_phase=(\n                raw.ev_charger.data.ac.phase_1.power_reactive.value,\n                raw.ev_charger.data.ac.phase_2.power_reactive.value,\n                raw.ev_charger.data.ac.phase_3.power_reactive.value,\n            ),\n            current_per_phase=(\n                raw.ev_charger.data.ac.phase_1.current.value,\n                raw.ev_charger.data.ac.phase_2.current.value,\n                raw.ev_charger.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.ev_charger.data.ac.phase_1.voltage.value,\n                raw.ev_charger.data.ac.phase_2.voltage.value,\n                raw.ev_charger.data.ac.phase_3.voltage.value,\n            ),\n            active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n            active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n            active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n            active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n            cable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\n            component_state=EVChargerComponentState.from_pb(\n                raw.ev_charger.state.component_state\n            ),\n            frequency=raw.ev_charger.data.ac.frequency.value,\n        )\n        ev_charger_data._set_raw(raw=raw)\n        return ev_charger_data\n\n    def is_ev_connected(self) -&gt; bool:\n        \"\"\"Check whether an EV is connected to the charger.\n\n        Returns:\n            When the charger is not in an error state, whether an EV is connected to\n                the charger.\n        \"\"\"\n        return self.component_state not in (\n            EVChargerComponentState.AUTHORIZATION_REJECTED,\n            EVChargerComponentState.ERROR,\n        ) and self.cable_state in (\n            EVChargerCableState.EV_LOCKED,\n            EVChargerCableState.EV_PLUGGED,\n        )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The total active 3-phase AC power, in Watts (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power_exclusion_lower_bound","title":"active_power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for EV charger power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power_exclusion_upper_bound","title":"active_power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for EV charger power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power_inclusion_lower_bound","title":"active_power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for EV charger power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power_inclusion_upper_bound","title":"active_power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for EV charger power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.active_power_per_phase","title":"active_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>active_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.cable_state","title":"cable_state  <code>instance-attribute</code>","text":"<pre><code>cable_state: EVChargerCableState\n</code></pre> <p>The state of the ev charger's cable.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.component_state","title":"component_state  <code>instance-attribute</code>","text":"<pre><code>component_state: EVChargerComponentState\n</code></pre> <p>The state of the ev charger.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively.</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>AC frequency, in Hertz (Hz).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.reactive_power","title":"reactive_power  <code>instance-attribute</code>","text":"<pre><code>reactive_power: float\n</code></pre> <p>The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.reactive_power_per_phase","title":"reactive_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>reactive_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).</p> <p>The provided values are for phase 1, 2, and 3 respectively.</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; Self\n</code></pre> <p>Create EVChargerData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Instance of EVChargerData created from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: PbComponentData) -&gt; Self:\n    \"\"\"Create EVChargerData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of EVChargerData created from the protobuf message.\n    \"\"\"\n    raw_power = raw.ev_charger.data.ac.power_active\n    ev_charger_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw_power.value,\n        active_power_per_phase=(\n            raw.ev_charger.data.ac.phase_1.power_active.value,\n            raw.ev_charger.data.ac.phase_2.power_active.value,\n            raw.ev_charger.data.ac.phase_3.power_active.value,\n        ),\n        reactive_power=raw.ev_charger.data.ac.power_reactive.value,\n        reactive_power_per_phase=(\n            raw.ev_charger.data.ac.phase_1.power_reactive.value,\n            raw.ev_charger.data.ac.phase_2.power_reactive.value,\n            raw.ev_charger.data.ac.phase_3.power_reactive.value,\n        ),\n        current_per_phase=(\n            raw.ev_charger.data.ac.phase_1.current.value,\n            raw.ev_charger.data.ac.phase_2.current.value,\n            raw.ev_charger.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.ev_charger.data.ac.phase_1.voltage.value,\n            raw.ev_charger.data.ac.phase_2.voltage.value,\n            raw.ev_charger.data.ac.phase_3.voltage.value,\n        ),\n        active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n        active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n        active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n        active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n        cable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\n        component_state=EVChargerComponentState.from_pb(\n            raw.ev_charger.state.component_state\n        ),\n        frequency=raw.ev_charger.data.ac.frequency.value,\n    )\n    ev_charger_data._set_raw(raw=raw)\n    return ev_charger_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.EVChargerData.is_ev_connected","title":"is_ev_connected","text":"<pre><code>is_ev_connected() -&gt; bool\n</code></pre> <p>Check whether an EV is connected to the charger.</p> RETURNS DESCRIPTION <code>bool</code> <p>When the charger is not in an error state, whether an EV is connected to the charger.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>def is_ev_connected(self) -&gt; bool:\n    \"\"\"Check whether an EV is connected to the charger.\n\n    Returns:\n        When the charger is not in an error state, whether an EV is connected to\n            the charger.\n    \"\"\"\n    return self.component_state not in (\n        EVChargerComponentState.AUTHORIZATION_REJECTED,\n        EVChargerComponentState.ERROR,\n    ) and self.cable_state in (\n        EVChargerCableState.EV_LOCKED,\n        EVChargerCableState.EV_PLUGGED,\n    )\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Fuse","title":"frequenz.client.microgrid.Fuse  <code>dataclass</code>","text":"<p>Fuse data class.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass Fuse:\n    \"\"\"Fuse data class.\"\"\"\n\n    max_current: float\n    \"\"\"Rated current of the fuse.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Fuse-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Fuse.max_current","title":"max_current  <code>instance-attribute</code>","text":"<pre><code>max_current: float\n</code></pre> <p>Rated current of the fuse.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GridMetadata","title":"frequenz.client.microgrid.GridMetadata  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentMetadata</code></p> <p>Metadata for a grid connection point.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass GridMetadata(ComponentMetadata):\n    \"\"\"Metadata for a grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GridMetadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.GridMetadata.fuse","title":"fuse  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuse: Fuse | None = None\n</code></pre> <p>The fuse at the grid connection point.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData","title":"frequenz.client.microgrid.InverterData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding inverter data.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass InverterData(ComponentData):  # pylint: disable=too-many-instance-attributes\n    \"\"\"A wrapper class for holding inverter data.\"\"\"\n\n    active_power: float\n    \"\"\"The total active 3-phase AC power, in Watts (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    active_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    reactive_power: float\n    \"\"\"The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    reactive_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).\n\n    The provided values are for phase 1, 2, and 3 respectively.\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    current_per_phase: tuple[float, float, float]\n    \"\"\"AC current in Amperes (A) for phase/line 1, 2 and 3 respectively.\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    voltage_per_phase: tuple[float, float, float]\n    \"\"\"The AC voltage in Volts (V) between the line and the neutral wire for\n       phase/line 1, 2 and 3 respectively.\n    \"\"\"\n\n    # pylint: disable=line-too-long\n    active_power_inclusion_lower_bound: float\n    \"\"\"Lower inclusion bound for inverter power in watts.\n\n    This is the lower limit of the range within which power requests are allowed for the\n    inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_lower_bound: float\n    \"\"\"Lower exclusion bound for inverter power in watts.\n\n    This is the lower limit of the range within which power requests are not allowed for\n    the inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_inclusion_upper_bound: float\n    \"\"\"Upper inclusion bound for inverter power in watts.\n\n    This is the upper limit of the range within which power requests are allowed for the\n    inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_upper_bound: float\n    \"\"\"Upper exclusion bound for inverter power in watts.\n\n    This is the upper limit of the range within which power requests are not allowed for\n    the inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n    # pylint: enable=line-too-long\n\n    frequency: float\n    \"\"\"AC frequency, in Hertz (Hz).\"\"\"\n\n    _component_state: PbInverterComponentState.ValueType\n    \"\"\"State of the inverter.\"\"\"\n\n    _errors: list[PbInverterError]\n    \"\"\"List of errors from the component.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: PbComponentData) -&gt; Self:\n        \"\"\"Create InverterData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of InverterData created from the protobuf message.\n        \"\"\"\n        raw_power = raw.inverter.data.ac.power_active\n        inverter_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw.inverter.data.ac.power_active.value,\n            active_power_per_phase=(\n                raw.inverter.data.ac.phase_1.power_active.value,\n                raw.inverter.data.ac.phase_2.power_active.value,\n                raw.inverter.data.ac.phase_3.power_active.value,\n            ),\n            reactive_power=raw.inverter.data.ac.power_reactive.value,\n            reactive_power_per_phase=(\n                raw.inverter.data.ac.phase_1.power_reactive.value,\n                raw.inverter.data.ac.phase_2.power_reactive.value,\n                raw.inverter.data.ac.phase_3.power_reactive.value,\n            ),\n            current_per_phase=(\n                raw.inverter.data.ac.phase_1.current.value,\n                raw.inverter.data.ac.phase_2.current.value,\n                raw.inverter.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.inverter.data.ac.phase_1.voltage.value,\n                raw.inverter.data.ac.phase_2.voltage.value,\n                raw.inverter.data.ac.phase_3.voltage.value,\n            ),\n            active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n            active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n            active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n            active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n            frequency=raw.inverter.data.ac.frequency.value,\n            _component_state=raw.inverter.state.component_state,\n            _errors=list(raw.inverter.errors),\n        )\n\n        inverter_data._set_raw(raw=raw)\n        return inverter_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The total active 3-phase AC power, in Watts (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power_exclusion_lower_bound","title":"active_power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for inverter power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power_exclusion_upper_bound","title":"active_power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for inverter power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power_inclusion_lower_bound","title":"active_power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for inverter power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power_inclusion_upper_bound","title":"active_power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for inverter power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.active_power_per_phase","title":"active_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>active_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1, 2 and 3 respectively.</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>AC frequency, in Hertz (Hz).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.reactive_power","title":"reactive_power  <code>instance-attribute</code>","text":"<pre><code>reactive_power: float\n</code></pre> <p>The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.reactive_power_per_phase","title":"reactive_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>reactive_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).</p> <p>The provided values are for phase 1, 2, and 3 respectively.</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1, 2 and 3 respectively.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; Self\n</code></pre> <p>Create InverterData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Instance of InverterData created from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: PbComponentData) -&gt; Self:\n    \"\"\"Create InverterData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of InverterData created from the protobuf message.\n    \"\"\"\n    raw_power = raw.inverter.data.ac.power_active\n    inverter_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw.inverter.data.ac.power_active.value,\n        active_power_per_phase=(\n            raw.inverter.data.ac.phase_1.power_active.value,\n            raw.inverter.data.ac.phase_2.power_active.value,\n            raw.inverter.data.ac.phase_3.power_active.value,\n        ),\n        reactive_power=raw.inverter.data.ac.power_reactive.value,\n        reactive_power_per_phase=(\n            raw.inverter.data.ac.phase_1.power_reactive.value,\n            raw.inverter.data.ac.phase_2.power_reactive.value,\n            raw.inverter.data.ac.phase_3.power_reactive.value,\n        ),\n        current_per_phase=(\n            raw.inverter.data.ac.phase_1.current.value,\n            raw.inverter.data.ac.phase_2.current.value,\n            raw.inverter.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.inverter.data.ac.phase_1.voltage.value,\n            raw.inverter.data.ac.phase_2.voltage.value,\n            raw.inverter.data.ac.phase_3.voltage.value,\n        ),\n        active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n        active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n        active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n        active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n        frequency=raw.inverter.data.ac.frequency.value,\n        _component_state=raw.inverter.state.component_state,\n        _errors=list(raw.inverter.errors),\n    )\n\n    inverter_data._set_raw(raw=raw)\n    return inverter_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType","title":"frequenz.client.microgrid.InverterType","text":"<p>             Bases: <code>ComponentType</code></p> <p>Enum representing inverter types.</p> Source code in <code>frequenz/client/microgrid/_component.py</code> <pre><code>class InverterType(ComponentType):\n    \"\"\"Enum representing inverter types.\"\"\"\n\n    NONE = PbInverterType.TYPE_UNSPECIFIED\n    \"\"\"Unspecified inverter type.\"\"\"\n\n    BATTERY = PbInverterType.TYPE_BATTERY\n    \"\"\"Battery inverter.\"\"\"\n\n    SOLAR = PbInverterType.TYPE_SOLAR\n    \"\"\"Solar inverter.\"\"\"\n\n    HYBRID = PbInverterType.TYPE_HYBRID\n    \"\"\"Hybrid inverter.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType.BATTERY","title":"BATTERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY = TYPE_BATTERY\n</code></pre> <p>Battery inverter.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType.HYBRID","title":"HYBRID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HYBRID = TYPE_HYBRID\n</code></pre> <p>Hybrid inverter.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = TYPE_UNSPECIFIED\n</code></pre> <p>Unspecified inverter type.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.InverterType.SOLAR","title":"SOLAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOLAR = TYPE_SOLAR\n</code></pre> <p>Solar inverter.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location","title":"frequenz.client.microgrid.Location  <code>dataclass</code>","text":"<p>Metadata for the location of microgrid.</p> Source code in <code>frequenz/client/microgrid/_metadata.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Location:\n    \"\"\"Metadata for the location of microgrid.\"\"\"\n\n    latitude: float | None = None\n    \"\"\"The latitude of the microgrid in degree.\"\"\"\n\n    longitude: float | None = None\n    \"\"\"The longitude of the microgrid in degree.\"\"\"\n\n    timezone: ZoneInfo | None = None\n    \"\"\"The timezone of the microgrid.\n\n    If not passed during construction (or `None` is passed), and there is a `longitude`\n    and `latitude`, then the timezone wil be looked up in a database based on the\n    coordinates. This lookup could fail, in which case the timezone will still be\n    `None`.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Initialize the timezone of the microgrid.\"\"\"\n        if self.latitude is None or self.longitude is None or self.timezone is not None:\n            return\n\n        timezone = _timezone_finder.timezone_at(lat=self.latitude, lng=self.longitude)\n        if timezone:\n            # The dataclass is frozen, so it needs to use __setattr__ to set the timezone.\n            object.__setattr__(self, \"timezone\", ZoneInfo(key=timezone))\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float | None = None\n</code></pre> <p>The latitude of the microgrid in degree.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float | None = None\n</code></pre> <p>The longitude of the microgrid in degree.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location.timezone","title":"timezone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timezone: ZoneInfo | None = None\n</code></pre> <p>The timezone of the microgrid.</p> <p>If not passed during construction (or <code>None</code> is passed), and there is a <code>longitude</code> and <code>latitude</code>, then the timezone wil be looked up in a database based on the coordinates. This lookup could fail, in which case the timezone will still be <code>None</code>.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Location.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Initialize the timezone of the microgrid.</p> Source code in <code>frequenz/client/microgrid/_metadata.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Initialize the timezone of the microgrid.\"\"\"\n    if self.latitude is None or self.longitude is None or self.timezone is not None:\n        return\n\n    timezone = _timezone_finder.timezone_at(lat=self.latitude, lng=self.longitude)\n    if timezone:\n        # The dataclass is frozen, so it needs to use __setattr__ to set the timezone.\n        object.__setattr__(self, \"timezone\", ZoneInfo(key=timezone))\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Metadata","title":"frequenz.client.microgrid.Metadata  <code>dataclass</code>","text":"<p>Metadata for the microgrid.</p> Source code in <code>frequenz/client/microgrid/_metadata.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Metadata:\n    \"\"\"Metadata for the microgrid.\"\"\"\n\n    microgrid_id: int | None = None\n    \"\"\"The ID of the microgrid.\"\"\"\n\n    location: Location | None = None\n    \"\"\"The location of the microgrid.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Metadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Metadata.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: Location | None = None\n</code></pre> <p>The location of the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.Metadata.microgrid_id","title":"microgrid_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int | None = None\n</code></pre> <p>The ID of the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData","title":"frequenz.client.microgrid.MeterData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding meter data.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass MeterData(ComponentData):\n    \"\"\"A wrapper class for holding meter data.\"\"\"\n\n    active_power: float\n    \"\"\"The total active 3-phase AC power, in Watts (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    active_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    reactive_power: float\n    \"\"\"The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    reactive_power_per_phase: tuple[float, float, float]\n    \"\"\"The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).\n\n    The provided values are for phase 1, 2, and 3 respectively.\n\n    * Positive power means capacitive (current leading w.r.t. voltage).\n    * Negative power means inductive (current lagging w.r.t. voltage).\n    \"\"\"\n\n    current_per_phase: tuple[float, float, float]\n    \"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n\n    Represented in the passive sign convention.\n\n    * Positive means consumption from the grid.\n    * Negative means supply into the grid.\n    \"\"\"\n\n    voltage_per_phase: tuple[float, float, float]\n    \"\"\"The ac voltage in volts (v) between the line and the neutral wire for phase/line\n        1,2 and 3 respectively.\n    \"\"\"\n\n    frequency: float\n    \"\"\"The AC power frequency in Hertz (Hz).\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: PbComponentData) -&gt; Self:\n        \"\"\"Create MeterData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of MeterData created from the protobuf message.\n        \"\"\"\n        meter_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw.meter.data.ac.power_active.value,\n            active_power_per_phase=(\n                raw.meter.data.ac.phase_1.power_active.value,\n                raw.meter.data.ac.phase_2.power_active.value,\n                raw.meter.data.ac.phase_3.power_active.value,\n            ),\n            reactive_power=raw.meter.data.ac.power_reactive.value,\n            reactive_power_per_phase=(\n                raw.meter.data.ac.phase_1.power_reactive.value,\n                raw.meter.data.ac.phase_2.power_reactive.value,\n                raw.meter.data.ac.phase_3.power_reactive.value,\n            ),\n            current_per_phase=(\n                raw.meter.data.ac.phase_1.current.value,\n                raw.meter.data.ac.phase_2.current.value,\n                raw.meter.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.meter.data.ac.phase_1.voltage.value,\n                raw.meter.data.ac.phase_2.voltage.value,\n                raw.meter.data.ac.phase_3.voltage.value,\n            ),\n            frequency=raw.meter.data.ac.frequency.value,\n        )\n        meter_data._set_raw(raw=raw)\n        return meter_data\n</code></pre>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The total active 3-phase AC power, in Watts (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.active_power_per_phase","title":"active_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>active_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC active power for phase 1, 2, and 3 respectively, in Watt (W).</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively.</p> <p>Represented in the passive sign convention.</p> <ul> <li>Positive means consumption from the grid.</li> <li>Negative means supply into the grid.</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>The AC power frequency in Hertz (Hz).</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.reactive_power","title":"reactive_power  <code>instance-attribute</code>","text":"<pre><code>reactive_power: float\n</code></pre> <p>The total reactive 3-phase AC power, in Volt-Ampere Reactive (VAr).</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.reactive_power_per_phase","title":"reactive_power_per_phase  <code>instance-attribute</code>","text":"<pre><code>reactive_power_per_phase: tuple[float, float, float]\n</code></pre> <p>The per-phase AC reactive power, in Volt-Ampere Reactive (VAr).</p> <p>The provided values are for phase 1, 2, and 3 respectively.</p> <ul> <li>Positive power means capacitive (current leading w.r.t. voltage).</li> <li>Negative power means inductive (current lagging w.r.t. voltage).</li> </ul>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The ac voltage in volts (v) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/microgrid/#frequenz.client.microgrid.MeterData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; Self\n</code></pre> <p>Create MeterData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Instance of MeterData created from the protobuf message.</p> Source code in <code>frequenz/client/microgrid/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: PbComponentData) -&gt; Self:\n    \"\"\"Create MeterData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of MeterData created from the protobuf message.\n    \"\"\"\n    meter_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw.meter.data.ac.power_active.value,\n        active_power_per_phase=(\n            raw.meter.data.ac.phase_1.power_active.value,\n            raw.meter.data.ac.phase_2.power_active.value,\n            raw.meter.data.ac.phase_3.power_active.value,\n        ),\n        reactive_power=raw.meter.data.ac.power_reactive.value,\n        reactive_power_per_phase=(\n            raw.meter.data.ac.phase_1.power_reactive.value,\n            raw.meter.data.ac.phase_2.power_reactive.value,\n            raw.meter.data.ac.phase_3.power_reactive.value,\n        ),\n        current_per_phase=(\n            raw.meter.data.ac.phase_1.current.value,\n            raw.meter.data.ac.phase_2.current.value,\n            raw.meter.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.meter.data.ac.phase_1.voltage.value,\n            raw.meter.data.ac.phase_2.voltage.value,\n            raw.meter.data.ac.phase_3.voltage.value,\n        ),\n        frequency=raw.meter.data.ac.frequency.value,\n    )\n    meter_data._set_raw(raw=raw)\n    return meter_data\n</code></pre>"}]}